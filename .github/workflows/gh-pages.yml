name: Build & Publish to GitHub Pages

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Version (e.g. 1.0.0)"
        required: true
        default: "1.0.0"
      channel:
        description: "Update channel"
        required: true
        default: "stable"

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      APP_BIN: bootrap-sample
      VERSION: ${{ inputs.version }}
      CHANNEL: ${{ inputs.channel }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: '1.24.x'

      - name: Prepare
        run: |
          set -euxo pipefail
          mkdir -p dist pack
          date -u +"%Y-%m-%dT%H:%M:%SZ" > .created_at

      - name: Write Ed25519 private key
        env:
          ED25519_PRIVATE_PEM: ${{ secrets.ED25519_PRIVATE_PEM }}
        run: |
          set -euo pipefail
          test -n "${ED25519_PRIVATE_PEM:-}" || { echo "Missing ED25519_PRIVATE_PEM secret" >&2; exit 1; }
          umask 077
          printf "%s" "$ED25519_PRIVATE_PEM" > private.pem
          openssl pkey -in private.pem -pubout -out public.pem
          echo "Public key (paste into Bootrap config.yaml):"
          cat public.pem

      - name: Build (linux/windows/macos)
        run: |
          set -euxo pipefail
          for t in linux/amd64 linux/arm64 windows/amd64 windows/arm64 darwin/amd64 darwin/arm64; do
            GOOS=${t%/*}; GOARCH=${t#*/};
            BIN="$APP_BIN"; [ "$GOOS" = windows ] && BIN="${APP_BIN}.exe"
            OUT="pack/${GOOS}-${GOARCH}/bin"
            mkdir -p "$OUT"
            GOOS=$GOOS GOARCH=$GOARCH CGO_ENABLED=0 go build -trimpath -ldflags "-s -w" -o "$OUT/$BIN" ./...
          done

      - name: Package (dist/<version>_<os-arch>.*)
        run: |
          set -euxo pipefail
          for d in pack/*; do
            flavor=$(basename "$d") # e.g. linux-amd64
            case "$flavor" in
              linux-*)
                # before: tar -C "$d" -czf "dist/${VERSION}_${flavor}.tar.gz" .
                tar -C "$d" -czf "dist/${VERSION}_${flavor}.tar.gz" bin
                ;;
              *)
                # before: (cd "$d" && zip -rq "../../dist/${VERSION}_${flavor}.zip" .)
                (cd "$d" && zip -rq "../../dist/${VERSION}_${flavor}.zip" bin)
                ;;
            esac
          done
          ls -l dist

      - name: Hash & Sign
        run: |
          set -euxo pipefail
          shopt -s nullglob
          for f in dist/*.{zip,tar.gz}; do
            [ -f "$f" ] || continue
            sha256sum "$f" | awk '{print $1}' > "$f.sha256"
            openssl pkeyutl -sign -rawin -inkey private.pem -in "$f" -out sig.bin
            base64 -w0 < sig.bin > "$f.sig.b64"
            rm -f sig.bin
          done

      - name: Generate manifest.json
        env:
          BASE: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/dist
          VERSION: ${{ env.VERSION }}
          CHANNEL: ${{ env.CHANNEL }}
        run: |
          set -euo pipefail
          CRE=$(cat .created_at)
          cat > gen.go <<'EOF'
          package main
          import ("encoding/json";"os";"path/filepath";"strings";"time")
          type Artifact struct {
            OS, Arch, URL, SHA256, Signature, Format string
          }
          type Version struct {
            Version   string     `json:"version"`
            Channel   string     `json:"channel"`
            CreatedAt time.Time  `json:"created_at"`
            Artifacts []Artifact `json:"artifacts"`
          }
          type Manifest struct {
            ManifestVersion int       `json:"manifest_version"`
            Versions        []Version `json:"versions"`
          }
          func main() {
            v := os.Getenv("VERSION"); c := os.Getenv("CHANNEL"); b := os.Getenv("BASE"); cre := os.Getenv("CRE")
            files, _ := filepath.Glob("dist/*")
            arts := []Artifact{}
            for _, f := range files {
              bn := filepath.Base(f)
              if !(strings.HasSuffix(bn,".zip")||strings.HasSuffix(bn,".tar.gz")) { continue }
              parts := strings.SplitN(bn, "_", 2); if len(parts)!=2 { continue }
              osarch := strings.TrimSuffix(strings.TrimSuffix(parts[1], ".zip"), ".tar.gz")
              p := strings.SplitN(osarch, "-", 2); if len(p)!=2 { continue }
              fmt := "zip"; if strings.HasSuffix(bn, ".tar.gz") { fmt = "tar.gz" }
              sha, _ := os.ReadFile("dist/"+bn+".sha256")
              sig, _ := os.ReadFile("dist/"+bn+".sig.b64")
              arts = append(arts, Artifact{
                OS: p[0], Arch: p[1],
                URL: strings.TrimRight(b, "/") + "/" + bn,
                SHA256: strings.TrimSpace(string(sha)),
                Signature: strings.TrimSpace(string(sig)),
                Format: fmt,
              })
            }
            t, _ := time.Parse(time.RFC3339, cre)
            m := Manifest{ManifestVersion: 1, Versions: []Version{{Version: v, Channel: c, CreatedAt: t, Artifacts: arts}}}
            e := json.NewEncoder(os.Stdout); e.SetIndent("", "  "); _ = e.Encode(m)
          }
          EOF
          CRE="$CRE" go run ./gen.go > manifest.json
          cat manifest.json

      - name: Prepare Pages artifact
        run: |
          set -euxo pipefail
          mkdir -p site/dist
          cp -v manifest.json site/
          cp -v public.pem site/
          cp -v dist/* site/dist/

      - uses: actions/upload-pages-artifact@v3
        with:
          path: site

      - uses: actions/deploy-pages@v4
